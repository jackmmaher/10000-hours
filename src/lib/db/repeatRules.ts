/**
 * RepeatRule Helpers
 *
 * CRUD operations and session generation for recurring planned sessions.
 */

import { db } from './schema'
import type { RepeatRule, RepeatFrequency, PlannedSession } from './types'

// CRUD Operations

export async function addRepeatRule(
  rule: Omit<RepeatRule, 'id' | 'createdAt'>
): Promise<RepeatRule> {
  const newRule: RepeatRule = {
    ...rule,
    createdAt: Date.now(),
  }
  const id = await db.repeatRules.add(newRule)
  return { ...newRule, id }
}

export async function getRepeatRule(id: number): Promise<RepeatRule | undefined> {
  return db.repeatRules.get(id)
}

export async function updateRepeatRule(
  id: number,
  updates: Partial<Omit<RepeatRule, 'id' | 'createdAt'>>
): Promise<void> {
  await db.repeatRules.update(id, updates)
}

export async function deleteRepeatRule(id: number): Promise<void> {
  // Delete all planned sessions generated by this rule
  await db.plannedSessions.where('repeatRuleId').equals(id).delete()
  // Delete the rule itself
  await db.repeatRules.delete(id)
}

export async function getAllRepeatRules(): Promise<RepeatRule[]> {
  return db.repeatRules.orderBy('createdAt').reverse().toArray()
}

// Session Generation

/**
 * Generate PlannedSession records from a RepeatRule
 * @param rule The repeat rule to generate from
 * @param weeksAhead How many weeks ahead to generate (default 4)
 * @returns Array of PlannedSession objects (not yet saved)
 */
export function generateSessionsFromRule(
  rule: RepeatRule,
  weeksAhead: number = 4
): Omit<PlannedSession, 'id'>[] {
  const sessions: Omit<PlannedSession, 'id'>[] = []

  const today = new Date()
  today.setHours(0, 0, 0, 0)

  const endDate = rule.endDate
    ? new Date(Math.min(rule.endDate, today.getTime() + weeksAhead * 7 * 24 * 60 * 60 * 1000))
    : new Date(today.getTime() + weeksAhead * 7 * 24 * 60 * 60 * 1000)

  const dates = getRepeatDates(rule.frequency, rule.customDays, today, endDate)

  for (const date of dates) {
    sessions.push({
      date: date.getTime(),
      plannedTime: rule.plannedTime,
      duration: rule.duration,
      title: rule.title,
      pose: rule.pose,
      discipline: rule.discipline,
      notes: rule.notes,
      sourceTemplateId: rule.sourceTemplateId,
      attachedPearlId: rule.attachedPearlId,
      repeatRuleId: rule.id,
      createdAt: Date.now(),
    })
  }

  return sessions
}

/**
 * Generate dates based on repeat frequency
 */
function getRepeatDates(
  frequency: RepeatFrequency,
  customDays: number[] | undefined,
  start: Date,
  end: Date
): Date[] {
  const dates: Date[] = []
  const current = new Date(start)
  const startDayOfWeek = start.getDay()

  while (current <= end) {
    const dayOfWeek = current.getDay()
    let include = false

    switch (frequency) {
      case 'daily':
        include = true
        break
      case 'weekly':
        // Weekly repeats on the same day of week as start
        include = dayOfWeek === startDayOfWeek
        break
      case 'weekdays':
        // Monday (1) through Friday (5)
        include = dayOfWeek >= 1 && dayOfWeek <= 5
        break
      case 'custom':
        // User-selected days
        include = customDays?.includes(dayOfWeek) ?? false
        break
    }

    if (include) {
      dates.push(new Date(current))
    }

    current.setDate(current.getDate() + 1)
  }

  return dates
}

/**
 * Save generated sessions to database
 */
export async function saveGeneratedSessions(sessions: Omit<PlannedSession, 'id'>[]): Promise<void> {
  // Use bulkAdd for efficiency
  await db.plannedSessions.bulkAdd(sessions as PlannedSession[])
}

/**
 * Create a repeat rule and generate initial sessions
 */
export async function createRepeatRuleWithSessions(
  ruleData: Omit<RepeatRule, 'id' | 'createdAt'>,
  weeksAhead: number = 4
): Promise<RepeatRule> {
  // Create the rule
  const rule = await addRepeatRule(ruleData)

  // Generate and save sessions
  const sessions = generateSessionsFromRule(rule, weeksAhead)
  await saveGeneratedSessions(sessions)

  return rule
}
