---
phase: 01-fix-stale-plan-display
plan: 01
type: execute
---

<objective>
Fix bug where "Plan Your Next Meditation" shows stale completed session data after a meditation is completed.

Purpose: When a user completes a planned meditation, the "Your Next Moment" card should immediately reset to either show the next planned session or revert to "Plan your next meditation" CTA.

Output: Fixed state synchronization between session completion and Journey tab's plan display.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
</execution_context>

<context>
@.planning/codebase/CONCERNS.md
@.planning/codebase/ARCHITECTURE.md

**Bug Analysis (from codebase mapping):**

The issue is in `src/lib/db.ts` function `getNextPlannedSession()`:
- It correctly filters out completed plans (`p.completed || p.linkedSessionUuid`)
- BUT it only queries plans with `date >= today`
- When a session completes on the same day as its plan, the plan is marked completed
- However, Journey.tsx may have cached the old plan in React state before the effect re-runs

**Root cause:** State synchronization timing between:
- `src/stores/useSessionStore.ts:117` - marks plan completed after session ends
- `src/components/Journey.tsx:179-191` - `loadNextPlan()` effect may have stale state

**Why it "fixed itself" the next day:**
- On Jan 10, the date filter (`>= today`) naturally excluded the Jan 9 plan

**Key files:**
- `src/lib/db.ts` - getNextPlannedSession() function
- `src/components/Journey.tsx` - loadNextPlan effect and nextPlannedSession state
- `src/components/JourneyNextSession.tsx` - renders the "Your Next Moment" card
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add date validation in getNextPlannedSession</name>
  <files>src/lib/db.ts</files>
  <action>
Modify `getNextPlannedSession()` to be more robust by:
1. Adding explicit date validation - exclude plans where the date is in the past (before today)
2. This ensures even if a plan wasn't marked completed, it won't show if its date has passed

Current code (around line 648-667):
```typescript
export async function getNextPlannedSession(afterDate?: number): Promise<PlannedSession | undefined> {
  const today = new Date()
  today.setHours(0, 0, 0, 0)
  const todayTime = today.getTime()

  const plans = await db.plannedSessions
    .where('date')
    .aboveOrEqual(todayTime)
    .toArray()

  return plans
    .filter(p => {
      if (p.completed || p.linkedSessionUuid) return false
      if (afterDate !== undefined && isSameDay(p.date, afterDate)) return false
      return true
    })
    .sort((a, b) => a.date - b.date)[0]
}
```

The fix: Add an additional check in the filter to ensure plan.date >= todayTime:
```typescript
.filter(p => {
  if (p.completed || p.linkedSessionUuid) return false
  if (p.date < todayTime) return false  // Exclude past-day plans
  if (afterDate !== undefined && isSameDay(p.date, afterDate)) return false
  return true
})
```

This is defensive - the query already filters by date >= today, but adding it to the filter handles any edge cases with timezone or timestamp formats.
  </action>
  <verify>TypeScript compiles: `npm run build` or `npx tsc --noEmit`</verify>
  <done>getNextPlannedSession excludes plans with dates before today in both query AND filter</done>
</task>

<task type="auto">
  <name>Task 2: Force refresh after session completion</name>
  <files>src/stores/useSessionStore.ts</files>
  <action>
The session store's `completeSession` function calls `linkSessionToPlan()` but doesn't trigger a UI refresh. The Journey component relies on the `sessions` array changing to trigger re-fetch of plans.

However, the issue is that `sessions` updates AFTER `linkSessionToPlan` completes, and there may be a race condition.

To fix: Export a signal/event that Journey.tsx can subscribe to. Since Zustand is already in use, add a `planRefreshTrigger` counter to a store that Journey can watch.

Option A (Recommended - minimal change): Add a `lastPlanChange` timestamp to useSessionStore that gets updated when linkSessionToPlan succeeds.

In useSessionStore.ts, add to the store interface and state:
```typescript
interface SessionState {
  // ... existing fields
  lastPlanChange: number  // Timestamp of last plan modification
}
```

And in completeSession, after linkSessionToPlan:
```typescript
const linkedPlan = await linkSessionToPlan(sessionUuid, todayStart.getTime())
// Trigger plan refresh
set({ lastPlanChange: Date.now() })
```

Then in Journey.tsx, add `lastPlanChange` to the useEffect dependency for loadNextPlan:
```typescript
const { sessions, lastPlanChange } = useSessionStore()

useEffect(() => {
  const loadNextPlan = async () => { ... }
  loadNextPlan()
}, [sessions, plansRefreshKey, lastPlanChange])
```

This ensures the plan is re-fetched immediately after session completion marks the plan as completed.
  </action>
  <verify>TypeScript compiles: `npm run build` or `npx tsc --noEmit`</verify>
  <done>Session completion triggers immediate plan refresh via lastPlanChange timestamp</done>
</task>

<task type="auto">
  <name>Task 3: Update Journey.tsx to subscribe to lastPlanChange</name>
  <files>src/components/Journey.tsx</files>
  <action>
Update Journey.tsx to subscribe to the new `lastPlanChange` from useSessionStore:

1. Update the destructuring from useSessionStore (around line 54):
```typescript
const { sessions, lastPlanChange } = useSessionStore()
```

2. Update the loadNextPlan effect dependency array (around line 179-191):
```typescript
useEffect(() => {
  const loadNextPlan = async () => {
    const now = new Date()
    now.setHours(0, 0, 0, 0)
    const todayHasSession = dateHasSession(sessions, now)

    const skipDate = todayHasSession ? now.getTime() : undefined
    const nextPlan = await getNextPlannedSession(skipDate)
    setNextPlannedSession(nextPlan || null)
  }
  loadNextPlan()
}, [sessions, plansRefreshKey, lastPlanChange])  // Add lastPlanChange
```

This ensures that when a session completes and updates lastPlanChange, the Journey component immediately re-fetches the next planned session, which will now correctly return null or the next future plan.
  </action>
  <verify>TypeScript compiles: `npm run build` or `npx tsc --noEmit`</verify>
  <done>Journey.tsx re-fetches plans when lastPlanChange updates</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] No TypeScript errors
- [ ] Manual test: Plan a meditation for today, complete it, verify "Your Next Moment" resets immediately
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- "Plan Your Next Meditation" CTA resets immediately after completing a planned session
- No stale plan data shown after session completion
</success_criteria>

<output>
After completion, create `.planning/phases/01-fix-stale-plan-display/01-01-SUMMARY.md`:

# Phase 01 Plan 01: Fix Stale Plan Display Summary

**[One-liner describing what was fixed]**

## Accomplishments

- [Key fix 1]
- [Key fix 2]

## Files Modified

- `src/lib/db.ts` - Added date validation to getNextPlannedSession
- `src/stores/useSessionStore.ts` - Added lastPlanChange trigger
- `src/components/Journey.tsx` - Subscribe to lastPlanChange for immediate refresh

## Decisions Made

[Any decisions made during implementation]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase complete - bug fixed.
</output>
